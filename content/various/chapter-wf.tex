\chapter{Various}

\section{Intervals}
	\kactlimport{interval-container.h}
	\kactlimport{interval-cover.h}
	\kactlimport{constant-intervals.h}

\section{Misc. algorithms}
	% \kactlimport{floor.h}
	\kactlimport{ternary-search.h}
	% \kactlimport{merge-sort.h}
	% \kactlimport{radix-sort.h}
	% \kactlimport{postfix-notation-solver.h}
	\kactlimport{count-triangles.h}	
	% \kactlimport{karatsuba.h}
	% \kactlimport{count-inversions.h}
	% \kactlimport{histogram.h}
	% \kactlimport{date-manipulation.h}	
        % \kactlimport{n-queens.h}
	% \kactlimport{sudoku-solver.h}    
        \kactlimport{floyd-cycle.h}

\section{Dynamic programming}
	\kactlimport{divide-and-conquer-dp.h}
	\kactlimport{knuth-dp.h}
	% \kactlimport{cht-dp.h}
	% \kactlimport{edit-distance.h}
	%\kactlimport{LIS.h}
	\kactlimport{digit-dp.h}
	% \kactlimport{LCS.h}
	% \kactlimport{knapsack-unbounded.h}	
	% \kactlimport{knapsack-bounded.h}
	\kactlimport{knapsack-bounded-costs.h}
	% \kactlimport{knapsack-bitset.h}	
	\kactlimport{two-max-equal-sum.h}
	% \kactlimport{max-zero-submatrix.h}

% \section{Debugging tricks}
%	\begin{itemize}
%		\item \texttt{signal(SIGSEGV, [](int) \{ \_Exit(0); \});} converts segfaults into Wrong Answers.
%			Similarly one can catch SIGABRT (assertion failures) and SIGFPE (zero divisions).
%			\texttt{\_GLIBCXX\_DEBUG} violations generate SIGABRT (or SIGSEGV on gcc 5.4.0 apparently).
%		\item \texttt{feenableexcept(29);} kills the program on NaNs (\texttt 1), 0-divs (\texttt 4), infinities (\texttt 8) and denormals (\texttt{16}).
%	\end{itemize}

\section{Optimization tricks}
	\subsection{Bit hacks}
		\begin{itemize}
			%\item \texttt{x \& -x} is the least bit in \texttt{x}.
			%\item \texttt{for (int x = m; x; ) \{ --x \&= m; ... \}} loops over all subset masks of \texttt{m} (except \texttt{m} itself).
			\item \texttt{c = x\&-x, r = x+c; (((r\^{}x) >> 2)/c) | r} is the next number after \texttt{x} with the same number of bits set.
			\item \texttt{ rep(b,0,K) rep(i,0,(1 << K)) if (i \& 1 << b) D[i] += D[i\^{}(1 << b)]; } computes all sums of subsets.
		\end{itemize}
	%\subsection{Pragmas}
	%	\begin{itemize}
	%		\item \lstinline{#pragma GCC optimize ("Ofast")} will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
	%		\item \lstinline{#pragma GCC target ("avx,avx2")} can double performance of vectorized code, but causes crashes on old machines.
	%		\item \lstinline{#pragma GCC optimize ("trapv")} kills the program on integer overflows (but is really slow).
	%	\end{itemize}
	
	% \kactlimport{fast-input.h}
	% \kactlimport{pragmas.h}
	% \kactlimport{bump-allocator.h}
	% \kactlimport{small-ptr.h}
	% \kactlimport{bump-allocator-stl.h}
	% \kactlimport{hashmap.h}
	% \kactlimport{unrolling.h}
	% \kactlimport{SIMD.h}
	% \kactlimport{fast-mod.h}
	% \kactlimport{linked-list.h}
	% \kactlimport{custom-comparator.h}
	
\section {Bit Twiddling Hack}
    \kactlimport{hacks.h}
   %\kactlimport{bitset.h}
\section {Random Numbers}
    \kactlimport{random-numbers.h}
\section {Test Hash}
    \kactlimport{test-hash.h}
